# 1 데이터 모델링

## 1.1 데이터 모델링의 이해

### 1.1.1 데이터 모델의 이해

- 모델링의 특징
  - 추상화: 다양한 현상을 일정한 양식인 표기법에 의해 표현한다.
  - 단순화: 복잡한 현실세계를 쉽게 이해할 수 있도록 한다.
  - 명확화: 대상에 대한 애매모호함을 제거하고 정확하게 현상을 기술한다.




- 모델링의 세 가지 관점
  - 데이터 관점: 어떤 데이터와 관련 있는지 또는 데이터간의 관계는 무엇인지
  - 프로세스 관점: 실제 하고 있는 일은 무엇인지 또는 무엇을 해야 하는지
  - 데이터와 프로세스의 상관 관점: 처리하는 방법에 따라 데이터가 어떻게 영향을 받는지




- 데이터 모델링의 정의
  - 데이터 관점의 업무 분석
  - 현실세계의 데이터를 약속된 표기법으로 표현
  - 데이터베이스를 구축하기 위한 분석/설계




- 데이터 모델이 제공하는 기능
  - 가시화
  - 명세화
  - 구조화된 틀
  - 문서화
  - 집중하기 위해 세부사항 숨기기
  - 구체화된 상세 수준의 표현방법



- 데이터 모델링의 중요성 및 유의점
  - 파급효과(Leverage): 후반부로 갈수록 변경으로 인한 비용손실과 납기지연 가능성이 커진다. 따라서 다른 어떤 설계 과정보다 데이터 설계가 더 중요하다.
  - 복잡한 정보 요구사항의 간결한 표현(Conciseness): 설계 도면. 많은 관련자들이 참고한다.
  - 데이터 품질(Data Quality)
    - 중복(Duplication): 일관성을 깨뜨릴 확률 높임
    - 비유연성(Inflexibility): 작은 변화에 민감하면 유지보수 어려움
    - 비일관성(Inconsistency): 데이터간 상호 연관 관계를 명확히 정의하는 것이 필요 (Trigger 등)



- 데이터 모델링의 3단계
  - 개념적 데이터 모델링: 추상화 수준이 높고 업무중심의 포괄적인 모델링. 전사적 데이터 모델링. EA 수립시 이용.
  - 논리적 데이터 모델링: 업무의 Key, 속성, 관계를 정확히 표현. 정규화. 재사용성 높음.
  - 물리적 데이터 모델링: 실제 데이터베이스에 이식하기 위한 모델링




- 프로젝트 생명주기

  | 단계      | 데이터                  | 프로세스        |
  | --------- | ----------------------- | --------------- |
  | 전환/이행 | DB 전환                 | AP 설치         |
  | 테스트    | DB 튜닝                 | AP 테스트       |
  | 개발      | DB 구축, 변경, 관리     | AP 개발         |
  | 설계      | 물리 데이터 모델링      | AP 설계         |
  | 분석      | 개념/논리 데이터 모델링 | 프로세스 모델링 |

  지속적으로 상호 검증 수행하면서 완성도를 높인다.



- 데이터 독립성 확보
  - 각 View의 독립성을 유지하고 계층별 View에 영향을 주지 않고 변경이 가능하다.
  - 단계별 Schema에 따라 데이터 정의어(DDL)와 데이터 조직어(DML)가 다름을 제공한다.



- 데이터베이스 3단계 구조
  - 외부 단계: View 단계. 사용자 관점
    - 논리적 데이터 독립성: 개념 스키마가 변경되어도 외부 스키마에 영향을 주지 않음.
  - 개념적 단계: 조직 전체 통합 관점
    - 물리적 데이터 독립성: 내부 스키마가 변경되어도 외부/개념 스키마에 영향을 주지 않음.
  - 내부적 단계: 물리적 저장구조



- 데이터 모델링의 세 가지 요소
  - 업무가 관여하는 어떤 것(Things: Entity, Instance)
  - 업무가 관여하는 어떤 것 간의 관계(Relationships)
  - 어떤 것이 가지는 성격(Attributes)



- 데이터 모델링의 이해관계자
  - 프로젝트 개발자
  - DBA
  - Architecture
  - 현업 전문가



- ERD
  - Peter Chen의 Entity-relationship model(E-R model) 표기법
  - IE/Crow's Foot 표기법
  - ERD(Entity Realtionship Diagram): 각 업무분석에서 도출된 엔터티와 엔터티간의 관계를 이해하기 쉽게 도식화된 다이어그램으로 표시



- 좋은 데이터 모델의 요소
  - 완전성(Completeness): 업무에서 필요로 하는 모든 데이터가 데이터 모델에 정의
  - 중복배제(Non-Redundancy): 하나의 데이터베이스 내에 동일한 사실은 반드시 한 번만 기록
  - 업무규칙(Business Rules): 업무규칙은 데이터 모델에 표현하고 모든 사용자가 공유
  - 데이터 재사용(Data Reusability): 데이터의 통합성과 독립성 고려. 즉, 행위 주체가 되는/행위 대상이 되는/행위 자체에 대한 통합 모델이어야 하며 애플리케이션에 대해 독립적이어야 한다.
  - 의사소통(Communication): 업무 규칙들은 데이터 모델에 엔터티, 서브타입, 속성, 관계 등의 형태로 최대한 자세하게 표현되어야 한다.
  - 통합성(Integration): 동일한 데이터는 조직 전체에서 가급적 한 번만 정의되고 이를 참조하도록 한다.



### 1.1.2 엔터티 (Entity)

업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것(Thing)

- 엔터티의 개념
  - 변별 가능한 사물
  - 데이터베이스 내에서 변별 가능한 객체
  - 정보를 저장할 수 있는 것
  - 정보가 저장될 수 있는 사람, 장소, 물건, 사건, 개념 등

  - 공통점
    - 엔터티는 사람, 장소, 물건, 사건, 개념 등의 명사에 해당한다.
    - 엔터티는 업무상 관리가 필요한 관심사에 해당한다.
    - 엔터티는 저장이 되기 위한 어떤 것(Thing)이다.



- 엔터티의 특징
  - 업무에서 필요로 하는 정보
  - 식별이 가능해야 함 (식별자에 의해)
  - 인스턴스의 집합 (= 두 개 이상)
  - 업무프로세스에 의해 이용
  - 속성을 포함
  - 관계의 존재 (최소 한 개 이상)
    - 단 통계성 엔터티, 코드성 엔터티, 시스템 처리시 내부 필요에 의한 엔터티는 관계가 생략된다.



- 엔터티의 분류
  - 유무형에 따른 분류
    - 유형 엔터티(Tangible Entity): 물리적 형태가 있다.
      - e.g. 사원, 물품, 강사
    - 개념 엔터티(Conceptual Entity): 물리적 형태가 없다.
      - e.g. 조직, 보험상품
    - 사건 엔터티(Event Entity): 업무를 수행함에 따라 발생한다.
      - e.g. 주문, 청구, 미납
  - 발생시점에 따른 분류
    - 기본 엔터티(Fundamental Entity): 업무에 원래 존재하는 정보로 독립적으로 생성 가능하다. 타 엔터티의 부모 역할을 맡으며 자신의 고유한 주 식별자 소유한다. 
      - e.g. 사원, 부서, 고객, 상품, 자재
    - 중심 엔터티(Main Entity): 기본 엔터티로부터 발생되고 업무의 중심적인 역할을 한다. 데이터 양이 많이 발생한다. 다른 엔터티와의 관계를 통해 행위 엔터티를 생성한다.
      - e.g. 계약, 사고, 예금원장, 청구, 주문, 매출
    - 행위 엔터티(Active Entity): 두 개 이상의 부모 엔터티로부터 발생한다. 자주 내용이 수정되거나 데이터 양이 증가한다. 상세 설계단계 또는 프로세스와 상관모델링을 할 때 도출될 수 있다.
      - e.g. 주문목록, 사원변경이력



- 엔터티의 명명
  - 현업업무에서 사용하는 용어
  - 가능하면 약어를 사용하지 않는다.
  - 단수명사를 사용한다.
  - 모든 엔터티에서 유일하게 이름이 부여되어야 한다.
  - 생성의미대로 이름을 부여한다.



### 1.1.3 속성 (Attribute)

업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 단위

- 엔터티, 인스턴스, 속성, 속성값의 관계

  - 한 개의 엔터티는 두 개 이상의 인스턴스의 집합이어야 한다.
  - 한 개의 엔터티는 두 개 이상의 속성을 갖는다.
  - 한 개의 속성은 한 시점에 한 개의 속성을 갖는다.




- 속성의 특징

  - 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다.
  - 정규화 이론에 근간하여 정해진 주식별자에 함수적 종속성을 가져야 한다.
  - 하나의 속성에는 한 개의 값만을 가진다. 하나의 속성에 여러 개의 값이 있는 다중값일 경우 별도의 엔터티를 이용하여 분리한다.




- 속성의 분류
  - 속성의 특성에 따른 분류
    - 기본 속성(Basic Attribute): 업무로부터 추출한 모든 속성
    - 설계 속성(Designed Attribute): 유도 속성이라고도 한다. 데이터 모델링을 위해, 업무를 규칙화하기 위해 속성을 새로 만들거나 변형하여 정의한 속성
    - 파생 속성(Derived Attribute): 다른 속성에 영향을 받아 발생하는 속성
  - 엔터티 구성방식에 따른 분류
    - 슈퍼키(Super Key): 식별, key, key 조합
    - 후보키: 식별, 최소성
    - 기본키(Primary Key): 후보키 중 선택. 인덱스를 자동으로 생성한다.
    - 대체키: 후보키 중 선택되지 않은 나머지 키
    - 외래키(Foriegn Key)
    - 일반 속성: Key가 아닌 속성




- 도메인

  각 속성이 가질 수 있는 값의 범위

  즉, 엔터티 내에서 속성에 대한 데이터타입과 크기 그리고 제약사항을 지정하는 것



- 속성의 명령

  - 해당 업무에서 사용하는 이름을 부여한다.
  - 서술식 속성명은 사용하지 않는다.
  - 약어사용은 가급적 제한한다.
  - 전체 데이터 모델에서 유일성을 확보한다.



### 1.1.4 관계 (Relationship)

인스턴스 사이의 논리적인 연관성으로서 존재 또는 행위로서 서로에게 연광성이 부여된 상태

- 관계의 패어링
  - 엔터티 안의 인스턴스가 개별적으로 관계를 가지는 것은 패어링이라 한다.
  - 패어링의 집합을 관계로 표현한다.




- 관계의 분류

  - 존재에 의한 관계 (연관관계)
  - 행위에 의한 관계 (의존관계)




- 관계의 표기법
  - 관계명(Membership): 엔터티가 관계에 참여하는 형태

    - 관계는 두 개의 관계명을 갖는다. (양방향)
    - 명명규칙: 애매한 동사를 피하고 현재형으로 표현한다.

  - 관계차수(Degree/Cardinality): Crow's Foot
    - 1:1 (ONE TO ONE)
    - 1:M (ONE TO MANY)
    - M:M (MANY TO MANY)

  - 관계선택사양(Optionality)

    - 필수 참여(Mandatory Membership): 모든 참여자가 반드시 관계를 가진다. 타 엔터티의 참여자와 연결된다.
    - 선택 참여(Optional Membership): Foreign Key로 연결될 경우 Null이 허용된다. ERD에서는 선택참여하는 엔터티 쪽을 원으로 표시한다.




- 관계의 정의 및 읽는 방법
  - 관계의 체크사항
    - 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?
    - 두 개의 엔터티 사이에 정보의 조합이 발생되는가?
    - 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?
    - 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb)가 있는가? 
  - 관계 읽기
    - 기준(Source) 엔터티를 한 개(One) 또는 각(Each)으로 읽는다.
    - 대상(Target) 엔터티의 관계참여도 즉 개수(하나, 하나 이상)를 읽는다.
    - 관계선택사양과 관계명을 읽는다.



### 1.1.5 식별자

엔터티 내에서 인스턴스들을 구분할 수 있는 구분자

- 식별자의 특징
  - 유일성: 주식별자에 의해 엔터티 내에 모든 인스턴스들을 유일하게 구분함
  - 최소성: 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함
  - 불변성: 주식별자가 한 번 특정 엔터티에 지정되면 그 식별자의 값을 변하지 않아야 함
  - 존재성: 주식별자가 지정되면 반드시 데이터 값이 존재해야 함 




- 식별자 분류

  - 대표성 여부

    - 주식별자(Primary Identifier): 엔터티 내에서 각 어커런스를 구분할 수 있는 구분자이며, 타 엔터티와 참조관계를 연결할 수 있는 식별자
    - 보조식별자(Alternate Identifier): 엔터티 내에서 각 어커런스를 구분할 수 있는 구분자이나 대표성을 가지지 못해 참조관계 연결을 못함

  - 스스로 생성 여부

    - 내부식별자(International Identifier): 엔터티 내부에서 스스로 만들어지는 식별자
    - 외부식별자(Foreign Identifier): 타 엔터티와의 관계를 통해 타 엔터티로부터 받아오는 식별자

  - 속성의 수

    - 단일식별자(Single Identifier): 하나의 속성으로 구성된 식별자

    - 복합식별자(Composite Identifier): 둘 이상의 속성으로 구성된 식별자

      약 엔터티. PK는 하나인 것이 가장 좋다. 인덱스를 생성할 때 첫번째 식별자만 사용. 복합일 경우 문제 발생 가능

  - 대체 여부

    - 본질식별자: 업무에 의해 만들어지는 식별자
    - 인조식별자: 업무적으로 만들어지지는 않지만 원조식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자




- 주식별자 도출기준
  - 해당 업무에서 자주 이용
  - 명칭이나 내역과 같이 이름으로 기술되는 것은 부적절 (보통 일련번호, 코드 등으로 대체)
  - 속성 수 적게



- 식별자 관계와 비식별자 관계에 따른 식별자

  외부식별자(Foreign Identifier)는 자기 자신의 엔터티에서 필요한 속성이 아니라 다른 엔터티와의 관계를 통해 자식 쪽에 엔터티에 생성되는 속성을 외부식별자라 하며 데이터베이스 생성 시에 Foreign Key 역할을 한다.

  - 식별자 관계(Identifying Relationship)

    자식 엔터티의 주식별자로 부모의 주식별자가 상속이 되는 경우를 식별자 관계라고 지칭한다.

    부모로부터 받은 식별자를 자식 엔터티의 주식별자로 이용하는 경우는 Null 값이 오면 안되므로 반드시 부모 엔터티가 생성되어야 자기 자신의 엔터티가 생성되는 경우이다.

  - 비식별자 관계(Non-Identifying Relationship)

    - 부모 엔터티로부터 속성을 받았지만 자식 엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용하는 경우를 비식별자 관계라 한다.
    - 다음 네 가지 경우에 비식별자 관계에 의한 외부속성을 생성한다.
      - 자식 엔터티에서 받은 속성이 반드시 필수가 아니어도 무방하기 때문에 부모 없는 자식이 생성될 수 있는 경우
      - 엔터티별로 데이터의 생명주기를 다르게 관리할 경우. 예를 들어, 부모 엔터티의 인스턴스가 자식 엔터티와 관계를 가지고 있었지만 자식만 남겨두고 먼저 소멸될 수 있는 경우가 해당된다.
      - 여러 개의 엔터티가 하나의 엔터티로 통합되어 표현되었는데 각각의 엔터티가 별도의 관계를 가질 경우
      - 자식 엔터티에 주식별자로 사용하여도 되지만 자식 엔터티에서 별도의 주식별자를 생성하는 것이 더 유리하다고 판단될 경우

  - 식별자 관계로만 설정할 경우의 문제점

    지속적으로 식별자 관계를 연결한 데이터 모델의 PK 속성의 수는 데이터 모델의 흐름이 길어질수록 증가할 수 밖에 없는 구조를 가진다.

  - 비식별자 관계로만 설정할 경우의 문제점

    기준속성이 자식 엔터티로 상속되지 않아 데이터 조회가 어렵다. 부모 엔터티까지 찾아가야 한다. 따라서 불필요한 조인이 발생할 수 있다.



- 식별자 관계와 비식별자 관계 모델링

  - 비식별자 관계 선택 프로세스

    실제로 프로젝트를 전개할 때 식별자 관계와 비식별자 관계를 취사선택하여 연결하는 내공은 높은 수준의 데이터모델링 기술이다.

    식별자 관계에서 비식별자 관계를 파악하는 기술이 필요한데 다음 흐름에 따라 비식별자 관계를 선정하면 합리적으로 관계를 설정할 수 있다. 기본적으로 식별자 관계로 모든 관계가 연결되면서 다음 조건에 해당할 경우 비식별자 관계로 조정하면 된다.

    1. 관계의 강/약 분석: 약한 관계일 경우
    2. 자식테이블 독립 PK 필요: 독립 PK 구성
    3. SQL 복잡도 증가, 개발 생산성 저하: PK 속성 단순화

  - 식별자와 비식별자관계 비교

    | 항목               | 식별자 관계                                                  | 비식별자 관계                                                |
    | ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 목적               | 강한 연결관계 표현                                           | 약한 연결관계 표현                                           |
    | 자식 주식별자 영향 | 자식 주식별자의 구성에 포함됨                                | 자식 일반 속성에 포함됨                                      |
    | 표기법             | 실선                                                         | 점선                                                         |
    | 연결 고려사항      | - 반드시 부모엔터티 종속 <br> - 자식 주식별자 구성에 부모 주식별자 포함 필요 <br> - 상속받은 주식별자 속성을 타 엔터티에 이전 필요 | - 약한 종속 관계 <br> - 자식 주식별자 구성을 독립적으로 구성 <br> - 자식 주식별자 구성에 부모 주식별자 부분 필요 <br> - 상속받은 주식별자 속성을 타 엔터티에 차단 필요 <br> - 부모쪽의 관계참여가 선택관계 |





## 1.2 데이터 모델과 성능
### 1.2.1 성능 데이터 모델링의 개요
- 성능 데이터 모델링의 정의
  성능 데이터 모델링이란 데이터베이스 성능향상을 목적으로 설계단계의 데이터 모델링때부터 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것



- 성능 데이터 모델링 수행시점
  성능 향상을 위한 비용은 프로젝트 수행 중에 있어서 사전에 할수록 비용이 들지 않는다.
  특히 분석/설계 단계에서 데이터 모델에 성능을 고려한 데이터 모델링을 수행할 경우 성능저하에 따르 재업무(Rework) 비용을 최소화 할 수 있는 기회를 가지게 된다.



- 성능 데이터 모델링 고려사항
  - 데이터 모델링을 할 때 정규화를 정확하게 수행한다.
  - 데이터베이스 용량산정을 수행한다.
  - 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
    cf. 트랜잭션: 하나의 업무 단위. 원자성.
  - 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
  - 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등을 수행한다.
  - 성능관점에서 데이터 모델을 검증한다.



### 1.2.2 정규화와 성능
- 정규화를 통한 성능 향상 정략
  정규화를 수행한다는 것은 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반속성을 의존자로 하여 입력/수정/삭제 이상현상을 제거하는 것이다.
  데이터의 중복속성을 제거하고 결정자에 의해 동일한 의미의 일반속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다.
  따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.
  - 함수종속성: X -> Y
    결정자 y는 x에 함수적 종속
    결정자(determinant) -> 종속자(dependent)
    e.g.
    수강(<u>학번, 과목</u>, 성적, 학과, 이름)
    - 함수종속

      - <u>학번</u>, <u>과목</u> -> 성적

      - <u>학번</u> -> 학과, 이름

        완전함수종속/부분함수종속: 부분함수종속이 삽입/삭제/수정 이상현상을 발생시킨다.

    - 정규화 결과

      - 성적(<u>학번, 과목</u>, 성적)
      - 학생(<u>학번</u>, 학과, 이름)

- 정규화 이론

  | 정규화             | 정규화 내용                                                  |
  | ------------------ | ------------------------------------------------------------ |
  | 1차 정규화         | 함수종속, 복수의 속성값을 갖는 속성을 분리, 속성의 원자성 확보 -> 한 칸에 하나 |
  | 2차 정규화         | 함수종속, 주식별자에 완전종속적이지 않은 속성의 분리. 부분종속 속성(partial dependency attribute)을 분리 |
  | 3차 정규화         | 함수종속, 일반속성에 종속적인 속성의 분리. 이전종속 속성(transitive dependency)의 분리 |
  | 보이스-코드 정규화 | 함수종속, 결정자 안에 함수종속을 가진 주식별자 분리          |
  | 4차 정규화         | 다가 종속(multi-valued dependency) 속성 분리                 |
  | 5차 정규화         | 결합 종속(join dependency)일 경우는 두 개 이상의 N개로 분리  |

  - 제 1정규형(1NF): 모든 속성이 원자값
  - 제 2정규형(2NF): 부분함수 종속성 제거. 모두 완전함수종속
  - 제 3정규형(3NF): 이행적 함수 종속(transitive FD)을 제외. 지름길이 아니라 long path로 쪼갠다.
  - 보이스/코드 정규형(BCNF): 모든 결정자가 후보키.

  모든 정규형은 이전 정규형의 조건을 만족한다.

### 1.2.3 반정규화와 성능
중복성의 원리를 활용하여 데이터 조회시 성능을 향상시키는 역할
- 반정규화의 정의
  - 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법
  - 데이터 무결성이 깨질 수 있는 위험을 무릅쓰고 데이터를 중복하여 적용하는 이유는 데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되거나 경로가 너무 멀어 조인으로 인한 성능저하가 예상되거나 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행한다.
  - 비정규화는 아예 정규화를 수행하지 않은 모델을 지칭한다.




- 반정규화 적용 절차
  반정규화를 적용하기 위해서는 먼저 반정규화의 대상을 조사하고 다른 방법을 적용할 수 있는지 검토하고 그 이후에 반정규화를 적용하도록 한다.
  1. 반정규화 대상 조사
     1. 범위처리빈도수 조사
     2. 대량의 범위 처리 조사
     3. 통계성 프로세스 조사
     4. 테이블 조인 개수
  2. 다른 방법 유도 검토
     1. 뷰(view) 테이블
     2. 클러스터링 적용
     3. 인덱스의 조정
     4. 응용애플리케이션
  3. 반정규화 적용
     1. 테이블 반정규화
     2. 속성 반정규화
     3. 관계 반정규화




- 반정규화의 기법
  - 테이블 반정규화
  
    | 기법분류    | 기법                     | 내용                                                         |
    | ----------- | ------------------------ | ------------------------------------------------------------ |
    | 테이블 병합 | 1:1 관계 테이블병합      | 1:1 관계를 통합하여 성능 향상                                |
    | 테이블 병합 | 1:M 관계 테이블병합      | 1:M 관계를 통합하여 성능 향상                                |
    | 테이블 병합 | 슈퍼/서브타입 테이블병합 | 슈퍼/서브 관계를 통합하여 성능 향상                          |
    | 테이블 분할 | 수직분할                 | 칼럼 단위의 테이블을 디스크 I/O를 분산처리 하기 위해 테이블을 1:1로 분리하여 성능 향상(트랜잭션의 처리 유형 파악 선행) |
    | 테이블 분할 | 수평분할                 | 로우 단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능 향상하기 위해 로우 단위로 테이블을 쪼갬 |
    | 테이블 추가 | 중복테이블 추가          | 다른 업무이거나 서버가 다른 경우 동일한 테이블 구조를 중복하여 원격조인을 제거하여 성능 향상 |
    | 테이블 추가 | 통계테이블 추가          | SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 성능 향상   |
    | 테이블 추가 | 이력테이블 추가          | 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재하게 함 |
    | 테이블 추가 | 부분테이블 추가          | 하나의 테이블의 전체 칼럼 중 자주 이용하는 집중화된 칼럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 칼럼들을 모아놓은 별도의 반정규화된 테이블 생성 |

  - 칼럼 반정규화

    | 반정규화 기법                      | 내용                                                         |
    | ---------------------------------- | ------------------------------------------------------------ |
    | 중복 칼럼 추가                     | 조인에 의해 처리할 때 성능저하를 예방하기 위해 즉, 조인을 감소시키기 위해 중복된 칼럼을 위치시킴 |
    | 파생 칼럼 추가                     | 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해 미리 값을 계산하여 칼럼에 보관함. Derived Column이라고 함. |
    | 이력테이블 칼럼 추가               | 대량의 이력데이터를 처리할 때 불특정 날 조회나 최근 값을 조회할 때 나타날 수 있는 성능저하를 예방하기 위해 이력테이블에 기능성 칼럼(최근값 여부, 시작과 종료일자 등)을 추가함 |
    | PK에 의한 칼럼 추가                | 복합의미를 갖는 PK를 단일 속성으로 구성하였을 경우 발생. 단일 PK안에서 특정 값을 별도로 조회하는 경우 성능저하가 발생될 수 있음. 이 때 이미 PK 안에 데이터가 존재하지만 성능향상을 위해 일반속성으로 포함하는 방법 |
    | 응용시스템 오작동을 위한 칼럼 추가 | 업무적으로는 의미가 없지만 사용자가 데이터처리를 하다가 잘못 처리하여 원래 값으로 복구하기를 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법. 칼럼으로 보관하는 방법은 임시적 기법이지만 이력데이터 모델로 풀어내면 정상적인 데이터 모델 기법이 됨 |

  - 관계 반정규화

    | 반정규화 기법 | 내용                                                         |
    | ------------- | ------------------------------------------------------------ |
    | 중복관계 추가 | 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만 이 때 발생할 수 있는 성능저하를 예방하기 위해 추가적인 관계를 맺는 방법 |




### 1.2.4 대량 데이터에 따른 성능
- 대량 데이터 발생에 따른 테이블 분할 개요
  아무리 설계가 잘 되어 있는 데이터 모델이라고 하더라도 대량의 데이터가 하나의 테이블에 집야되어 있고 하나의 하드웨어 공간에 저장되어 있으면 성능저하를 피하기가 힘들다.
  하나의 테이블에 대량의 데이터가 존재하는 경우에는 인덱스의 Tree구조가 너무 커져 효율성이 떨어져 데이터를 처리(입력, 수정, 삭제, 조회)할 때 디스크 I/O를 많이 유발하게 된다. 또한 한 테이블에 많은 수의 칼럼이 존재하게 되면 데이터가 디스크의 여러 블록에 존재하므로 인해 디스크에서 데이터를 읽는 I/O량이 많아지게 되어 성능이 저하된다.



- 한 테이블에 많은 수의 칼럼을 가지고 있는 경우
  - 1:1 테이블 분할을 통한 성능 개선

  - 파티셔닝을 통한 성능 개선
    - RANGE PARTITION
    - LIST PARTITION
    - HASH PARTITON



- 테이블에 대한 수평분할/수직분할의 절차
  1. 데이터 모델링을 완성한다.
  2. 데이터베이스 용량산정을 한다.
  3. 대량 데이터가 처리되는 테이블에 대해서 트랜잭션 처리 패턴을 분석한다. (업무규칙)
  4. 칼럼 단위로 집중화된 처리가 발생하는지, 로우단위로 집중화된 처리가 발생하는지 분석하여 집중화된 단위로 테이블을 분리하는 것을 검토한다.



### 1.2.5 데이터베이스 구조와 성능
- 슈퍼타입/서브타입 모델의 변환 방법
  성능을 고려한 슈퍼타입과 서브타입의 모델 변환의 방법은 세 가지가 존재한다.
  - OneToOne Type: 1:1 타입
  - Plus Type: 슈퍼+서브 타입
  - Single Type: All in One 타입

  트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union 연산에 의해 성능이 저하될 수 있다.

  트랜잭션은 항상 슈퍼+서브 타입을 공통으로 처리하는데 개별로 유지되어 있거나 하나의 테이블로 집약되어 있어 성능이 저하되는 경우가 있다.

  트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합되어 있어 불필요하게 많은 양의 데이터가 집약되어 있어 성능이 저하될 수 있다.



- 슈퍼타입/서브타입 모델의 변환 기준
  - 데이터 양
  - 트랜잭션 유형



- 슈퍼/서브타입 데이터 모델의 변환타입 비교

  | 구분                          | OneToOneType                   | Plus Type                                 | Single Type                     |
  | ----------------------------- | ------------------------------ | ----------------------------------------- | ------------------------------- |
  | 특징                          | 개별 테이블 유지               | 슈퍼+서브타입 테이블                      | 하나의 테이블                   |
  | 확장성                        | 우수함                         | 보통                                      | 나쁨                            |
  | 조인성능                      | 나쁨                           | 나쁨                                      | 우수함                          |
  | I/O량 성능                    | 좋음                           | 좋음                                      | 나쁨                            |
  | 관리용이성                    | 좋지 않음                      | 좋지 않음                                 | 좋음(1개)                       |
  | 트랜잭션 유형에 따른 선택방법 | 개별 테이블로 접근이 많은 경우 | 슈퍼+서브 형식으로 데이터를 처리하는 경우 | 전체를 일괄적으로 처리하는 경우 |




- 인덱스 특성을 고려한 PK/FK 데이터베이스 성능 향상
  데이터를 조회할 때 가장 효과적으로 처리될 수 있도록 접근경로를 제공하는 오브젝트가 바로 인덱스이다.
  
  인덱스의 정렬되어 있는 특징으로 인해 데이터베이스 설계에 이 특징에 따라 설계에 반영해야 할 요소에 대해서는 반드시 알고 있어야 좋은 데이터 모델을 만들어낼 수 있게 된다.
  
  프로젝트에서 PK/FK 설계는 업무적 의미로도 매우 중요한 의미를 가지고 있지만 데이터를 접근할 때 경로를 제겅하는 성능의 측면에서도 중요한 의미를 가지고 있기 때문에 성능을 고려한 데이터베이스 설계가 될 수 있도록 설계단계 말에 컬러의 순서를 조정할 필요가 있다.
  
  일반적으로 프로젝트에서는 PK/FK 칼럼 순서의 중요성을 인지하지 못한 채로 데이터 모델링이 되어 있는 그 상태대로 바로 DDL을 생성함으로써 데이터베이스 데이터처리 성능에 문제를 유발하는 경우가 빈번하게 발생한다.
  
  테이블에 발생되는 트랜잭션의 조회 패턴에 따라 PK/FK 칼럼의 순서를 조정해야 한다.
  
  물리적인 모델링 단계에서는 스스로 생성된 PK순서 이외에 다른 엔터티로부터 상속받아 발생되는 PK순서까지 항상 주의하여 표시하도록 한다.
  
  인덱스의 특징은 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낼 수 있다. 앞쪽에 위치한 속성값이 가급적 '=' 아니면 최소한 범위 'BETWEEN', '<>'가 들어와야 인덱스를 이용할 수 있다.



### 1.2.6 분산 데이터베이스와 성능
- 분산 데이터베이스의 개요
  - 여러 곳으로 분산되어 있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스
  - 논리적으로 동일한 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터들의 모임. 물리적 Site 분산. 논리적으로 사용자 통합, 공유.




- 분산 데이터베이스의 투명성(Transparency)
  - 분할 투명성(단편화):  하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장
  - 위치 투명성: 사용하려는 데이터의 저장 장소 명시 불필요. 위치 정보가 System Catalog에 유지되어야 함
  - 지역사상 투명성: 지역 DBMS와 물리적 DB 사이의 Mapping 보장. 각 지역시스템 이름과 무관한 이름 사용 가능
  - 중복 투명성: DB 객체가 여러 site에 중복되어 있는지 알 필요가 없는 성질
  - 장애 투명성: 구성요소(DBMS, Computer)의 장애에 무관한 Transaction의 원자성 유지
  - 병행 투명성: 다수 Transaction 동시 수행시 결과의 일관성 유지. Time Stamp, 분산 2단계 Locking을 이용하여 구현




- 분산 데이터베이스의 장단점

  분산 환경의 데이터베이스를 성능이 우수하게 현장에서 가치 있게 사용하는 방법은 업무의 흐름을 보고 업무 구성에 따른 아키텍처 특징에 따라 데이터베이스를 구성하는 것이다.

  단순히 분산 환경에서 데이터베이스를 구축하는 것이 목적이 아니라, 업무의 특징에 따라 데이터베이스 분산구조를 선택적으로 설계하는 능력이 필요한 것이다.

  이러한 측면만을 보았을 때는 데이터베이스 분산설계라는 측면보다는 데이터베이스 구조설계(아키텍처)라는 의미로 이해해도 무방하다.
  - 장점
    - 지역 자치성. 점증적 시스템 용량 확장
    - 데이터의 가용성과 신뢰성 증가
    - 효용성과 융통성
    - 빠른 응답 속도와 통신비용 절감
    - 시스템 규모의 적절한 조절
    - 각 지역 사용자의 요구 수용 증대
  - 단점
    - 소프트웨어 개발 비용
    - 오류의 잠재성 증대
    - 처리 비용의 증대
    - 설계, 관리의 복잡성과 비용
    - 불규칙한 응답 속도
    - 통제의 어려움
    - 데이터 무결성에 대한 위험



- 테이블 위치 분산

  테이블의 구조는 변하지 않는다.

  또한 테이블이 다른 데이터베이스에 중복되어 생성되지도 않는다.

  다만 설계된 테이블의 위치를 각각 다르게 위치시키는 것이다.



- 테이블 분할(Fragmentation) 분산
  - 수평분할(Horizontal Fragmentation)

    지사(Node)에 따라 테이블을 특정 칼럼의 값을 기준으로 행(Row)을 분리한다. 칼럼은 분리되지 않는다. 모든 데이터가 각 지사별로 분리되어 있는 형태를 가진다.

    각 지사에 있는 데이터와 다른 지사에 있는 데이터가 항상 배타적으로 존재하며, 데이터를 한 군데 집합시켜 놓아도 Primary Key에 의해 중복이 발생되지 않는다.

  - 수직분할(Vertical Fragmentation)

    지사에 따라 테이블 칼럼을 기준으로 칼럼(Column)을 분리한다. 행 단위로는 분리되지 않는다. 모든 데이터각 각 지사별로 분리되어 있는 형태를 가진다.

    칼럼을 기준으로 분할하였기 때문에 각각의 테이블에는 동일한 Primary Key 구조와 값을 가지고 있어야 한다.



- 테이블 복제(Replication) 분산
  - 부분복제(Segment Replication)

    통합된 테이블을 한 군데(본사)에 가지고 있으면서 각 지사별로는 지사에 해당된 행을 가지고 있는 형태이다.

    지사에 존재하는 데이터는 반드시 본사에 존재하게 된다. 즉 본사의 데이터는 지사데이터의 합이 된다.

    각 지사에서 데이터 처리가 용이할 뿐만 아니라 전체 데이터에 대한 통합처리도 본사에 있는 통합 테이블을 이용하게 되므로 여러 테이블에 조인(JOIN)이 발생하지 않아 빠른 작업 수행이 가능해진다.

  - 광역복제(Broadcast Replication)

    통합된 테이블을 한 군데(본사)에 가지고 있으면서 각 지사에도 본사와 동일한 데이터를 모두 가지고 있는 형태이다.

    지사에 존재하는 데이터는 반드시 본사에 존재하게 된다. 모든 지사에 있는 데이터량과 본사에 있는 데이터량이 모두 동일하다.

    본사와 지사 모두 동일한 정보를 가지고 있으므로 본사나 지사나 데이터 처리에 특별한 제약을 받지 않는다.



- 테이블 요약(Summarization) 분산
  - 분석요약(Rollup Replication)

    각 지사별로 존재하는 같은 내용의 정보를 본사에 통합하여 다시 전체에 대해서 요약정보를 산출한다.

  - 통합요약(Consolidation Replication)

    각 지사별로 존재하는 다른 내용의 정보를 본사에 통합하여 다시 전체에 대해서 요약정보를 산출한다.



- 분산 데이터베이스의 적용이 효과적인 경우
  - 성능이 중요한 사이트에 적용해야 한다.
  - 공통코드, 기준정보, 마스터 데이터 등에 대해 분산 환경을 구상하면 성능이 좋아진다.
  - 실시간 동기화가 요구되지 않을 때 좋다. 거의 실시간(Near Real Time)의 업무적인 특징을 가지고 있을 때도 분산 환경을 구성할 수 있다.
  - 특정 서버에 집중되는 부하를 분산하고자 할 때도 좋다.
  - 백업 사이트(Disaster Recovery Site)를 구성할 때 간단하게 분산기능을 적용하여 구성할 수 있다.



## Ref.
- SQL 전문가 가이드 2013 Edition
